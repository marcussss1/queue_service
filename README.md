# Сервис подсчета арифметической прогрессии в очереди

## Ручки

### `/docs/*`

API в формате SWAGGER, по ручке "/docs/*" можно посмотреть спецификацию.

### `/api/v1/tasks`

Список задач, которые есть в памяти.

### `/api/v1/append_task`

Добавляет задачу в очередь.

## Запуск

Порт и количество воркеров можно конфигурировать в internal/config/config.yaml

Для сборки образа
```shell
make build
```

Для запуска контейнера
```shell
make run
```

Для остановки контейнера
```shell
make stop
```

## Логика и архитектура проекта

Директории в приложении расположены в соотвествии с go-layout, сущности(tasks, workers) написаны при помощи чистой архитектуры.

tasks - отвечает за работу с задачами. На уровне delivery организован роутер, который принимает запросы. На уровне usecase минимальная логика похода в repository. На уровне repository организована логика с хранением задач, если подробнее, то 
есть ```tasks map[int]models.Task```, в нём хранятся, обновляются и удаляются по TTL сущности задач, выбрана именно мапа, а не слайс, потому что со слайсом может быть много проблем с выделением/перевыделением памяти, поддержанием логики. ```mutex sync.RWMutex```
так как у нас несколько воркеров имеют доступ к одному куску памяти, без мьютекса не обойтись. ```lastTaskIdx int``` - индекс последней добавленной задачи. ```freeTaskIdx int``` - индекс свободной задачи.


workers - отвечает за работу с очередью и поход в tasks_repository. Здесь только логика - usecase. Содержит в себе ```workers chan struct{}```, буферизированный(буфер задается в конфиге) канал, засчет него очень удобно организовывается очередь, ведь воркеру достаточно записать что-то в канал, а при выходе из него вычитать.
Вся логика сводится к вечному циклу, в котором мы ходим tasks_repository и достаем задачи, которые мы можем взять в работу, смотрим если freeTaskIdx >= lastTaskIdx, то это значит, что задач больше нет. Иначе в горутине запускаем функцию, которая
посчитает прогрессию, обновит статус, поставит время завершения подсчета и т.д., и асинхронно запустит функцию, которая через TTL время удалит из мапы задачу.
